# Surek - Complete LLM Documentation

Surek is a Docker Compose orchestration tool for self-hosted services. It manages Caddy reverse proxy for your containers with automatic HTTPS, backs up Docker volumes to S3-compatible storage, and includes Portainer and Netdata for container management and server monitoring.

## Table of Contents

1. [Core Concepts](#core-concepts)
2. [Directory Structure](#directory-structure)
3. [Configuration Schemas](#configuration-schemas)
4. [CLI Commands Reference](#cli-commands-reference)
5. [TUI Features](#tui-features)
6. [Writing Docker Compose Files](#writing-docker-compose-files)
7. [Template Variables](#template-variables)
8. [Network Architecture](#network-architecture)
9. [Deployment Pipeline](#deployment-pipeline)
10. [Backup System](#backup-system)
11. [Command Internals](#command-internals)

---

## Core Concepts

### Stacks

A **stack** is a collection of related Docker services managed together. Each stack lives in its own directory under `stacks/` and consists of:

- `surek.stack.yml` - Stack configuration file (required)
- `docker-compose.yml` - Docker Compose specification (required, can be pulled from GitHub)
- Additional files used by services (optional)

### System Stack

The **system stack** (`surek-system`) provides core infrastructure:

- **Caddy** - Reverse proxy with automatic HTTPS via Let's Encrypt
- **Portainer** - Web UI for container management (optional)
- **Netdata** - Server monitoring dashboard (optional)
- **Backup** - Scheduled volume backups to S3 (if configured)

The system stack must be running before deploying user stacks. Start it with:

```bash
surek start system
```

### Sources

Stacks can pull their files from two sources:

1. **Local** (`type: local`) - Files in the stack directory are used directly
2. **GitHub** (`type: github`) - Files are downloaded from a GitHub repository

---

## Directory Structure

```
project/
├── surek.yml                         # Main configuration
├── surek.config.schema.json          # JSON schema (auto-generated by `surek schema`)
├── surek.stack.schema.json           # JSON schema (auto-generated by `surek schema`)
├── stacks/                           # User-defined stacks
│   └── my-app/
│       ├── surek.stack.yml           # Stack configuration
│       ├── docker-compose.yml        # Compose file (for local sources)
│       └── config/                   # Additional files for the stack
└── surek-data/                       # Runtime data, managed by surek (add to .gitignore)
    ├── projects/                     # Deployed stack working directories
    │   ├── my-app/
    │   │   ├── docker-compose.yml    # Original compose file
    │   │   └── docker-compose.surek.yml  # Transformed compose file
    │   └── surek-system/
    │       ├── docker-compose.yml
    │       └── docker-compose.surek.yml
    ├── volumes/                      # Stack volume bind mounts (for backups)
    │   ├── my-app/
    │   │   ├── postgres_data/
    │   │   └── app_uploads/
    │   └── surek-system/
    │       ├── caddy_data/
    │       ├── portainer_data/
    │       └── netdata_*/
    └── github_cache.json             # GitHub commit hash cache
```

---

## Configuration Schemas

### Main Configuration (`surek.yml`)

```yaml
# yaml-language-server: $schema=./surek.config.schema.json

# Required: Root domain for all services
# All stack domains are subdomains of this domain
root_domain: example.com

# Required: Default credentials in "user:password" format
# Can be referenced in stack configs with <default_auth>, <default_user>, <default_password>
default_auth: admin:secretpassword

# Optional: S3 backup configuration
# If configured, enables automatic volume backups to S3-compatible storage
backup:
  password: encryption_password      # GPG encryption password for backups
  s3_endpoint: s3.amazonaws.com      # S3 endpoint (without https://)
  s3_bucket: my-backups              # S3 bucket name
  s3_access_key: AKIAIOSFODNN7EXAMPLE
  s3_secret_key: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY

# Optional: GitHub access for private repositories
github:
  pat: ghp_xxxxxxxxxxxxxxxxxxxx      # Personal Access Token with 'repo' scope

# Optional: Enable/disable system services (both default to true)
system_services:
  portainer: true   # Enable Portainer container management UI
  netdata: true     # Enable Netdata server monitoring
```

**Validation Rules:**
- `default_auth` must be in `user:password` format with exactly one colon
- Neither username nor password can be empty
- Environment variables are expanded: `${VAR}` or `${VAR:-default}`

### Stack Configuration (`stacks/<name>/surek.stack.yml`)

```yaml
# yaml-language-server: $schema=../../surek.stack.schema.json

# Required: Stack name
# Must start with alphanumeric, contain only alphanumeric/underscore/hyphen
# Reserved names: "system", "surek-system"
name: my-app

# Required: Source configuration
source:
  type: local      # Use files from this directory
  # OR
  type: github
  slug: owner/repo          # Uses HEAD/main branch
  # OR
  slug: owner/repo#branch   # Specific branch/tag/commit

# Optional: Path to compose file (default: ./docker-compose.yml)
compose_file_path: ./docker-compose.yml

# Optional: Public endpoints for reverse proxy
# Each endpoint creates a Caddy route
public:
  - domain: app.<root>              # Domain template (<root> = root_domain)
    target: myapp:8080              # Service name and port
    auth: <default_auth>            # Optional: HTTP basic auth (user:password format)

  - domain: api.<root>
    target: api-service:3000        # Port defaults to 80 if omitted
    # No auth = publicly accessible

# Optional: Environment variables for containers
env:
  # Applied to ALL services in the stack
  shared:
    - TZ=UTC
    - NODE_ENV=production

  # Per-service environment variables
  by_container:
    myapp:
      - DATABASE_URL=postgres://user:pass@db:5432/app
      - REDIS_URL=redis://redis:6379
    db:
      - POSTGRES_PASSWORD=secret

# Optional: Backup settings
backup:
  # Volumes to exclude from backup (e.g., caches, temporary data)
  exclude_volumes:
    - cache_data
    - tmp_volume
```

**Stack Name Validation:**
- Must start with alphanumeric character
- Can contain only: a-z, A-Z, 0-9, underscore (_), hyphen (-)
- Cannot be "system" or "surek-system" (reserved)

**Target Format:**
- `service:port` - Explicit port
- `service` - Port defaults to 80

**Domain Templates:**
- `<root>` is replaced with `root_domain` from surek.yml
- Example: `app.<root>` → `app.example.com`

---

## CLI Commands Reference

### Global Options

| Option | Description |
|--------|-------------|
| `--version`, `-v` | Show version and exit |
| `--help-llm` | Print this complete documentation |
| `--help-readme` | Print README documentation |
| `--help` | Show command help |
| `--install-completion` | Install shell completion for bash/zsh/fish/powershell |
| `--show-completion` | Show completion script for current shell |

### Shell Completion

Enable tab completion for stack names and commands:

```bash
# Install completion for your shell
surek --install-completion

# Restart your shell for changes to take place
```

After installation, pressing Tab will autocomplete:
- Command names (`surek dep<Tab>` → `surek deploy`)
- Stack names (`surek deploy my<Tab>` → `surek deploy my-app`)
- Options (`surek status --<Tab>` → shows available options)

### Project Initialization

#### `surek init`

Initialize a new Surek project interactively.

```bash
surek init [--git-only]
```

| Option | Description |
|--------|-------------|
| `--git-only` | Only add `surek-data` to .gitignore |

**What it does:**
1. Prompts for root domain
2. Prompts for default credentials
3. Optionally configures S3 backup
4. Optionally configures GitHub PAT
5. Creates `surek.yml`
6. Creates `stacks/` directory
7. Generates JSON schemas for editor autocompletion
8. Adds `surek-data` to `.gitignore`

#### `surek new`

Create a new stack interactively.

```bash
surek new
```

**What it does:**
1. Prompts for stack name
2. Prompts for source type (local/github)
3. Prompts for compose file path
4. Prompts for public endpoints
5. Creates `stacks/<name>/surek.stack.yml`
6. Creates empty `docker-compose.yml` for local sources

#### `surek schema`

Generate JSON schemas for configuration files.

```bash
surek schema
```

**What it does:**
1. Generates `surek.config.schema.json` from SurekConfig Pydantic model
2. Generates `surek.stack.schema.json` from StackConfig Pydantic model
3. Enables IDE autocompletion when added to YAML files

### Stack Management

#### `surek deploy <stack>`

Deploy a stack (pull sources, transform compose, start containers).

```bash
surek deploy <stack_name> [--pull]
```

| Argument | Description |
|----------|-------------|
| `stack_name` | Name of stack to deploy (use "system" for system containers) |

| Option | Description |
|--------|-------------|
| `--pull` | Force re-pull sources (GitHub) and Docker images |

**What it does:**
See [Deployment Pipeline](#deployment-pipeline) for complete details.

#### `surek start <stack>`

Start an already deployed stack without re-transformation.

```bash
surek start <stack_name>
```

| Argument | Description |
|----------|-------------|
| `stack_name` | Name of stack to start (use "system" for system containers) |

**What it does:**
1. Loads existing `docker-compose.surek.yml` from `surek-data/projects/<stack>/`
2. Runs `docker compose up -d --build`
3. For system stack: always re-deploys (transforms compose file)

#### `surek stop <stack>`

Stop a running stack.

```bash
surek stop <stack_name>
```

| Argument | Description |
|----------|-------------|
| `stack_name` | Name of stack to stop (use "system" for system containers) |

**What it does:**
1. Runs `docker compose stop` on the stack's compose file
2. Containers are stopped but not removed
3. Volumes are preserved

#### `surek status`

Show status of all stacks.

```bash
surek status [--json] [--stats/-s]
```

| Option | Description |
|--------|-------------|
| `--json` | Output as JSON |
| `--stats`, `-s` | Include CPU/memory usage (slower) |

**Output columns:**
- Stack name
- Status: `✓ Running`, `× Down`, `⚠ Partial`, `Invalid config`
- Health: `✓ healthy`, `⚠ X unhealthy`, `starting...`, `-`
- CPU (with `--stats`)
- Memory (with `--stats`)
- Endpoints (public URLs)

#### `surek info <stack>`

Show detailed information about a stack.

```bash
surek info <stack_name> [-l/--logs] [--json]
```

| Argument | Description |
|----------|-------------|
| `stack_name` | Name of stack (use "system" for system containers) |

| Option | Description |
|--------|-------------|
| `-l`, `--logs` | Include last 40 log lines |
| `--json` | Output as JSON |

**Output includes:**
- Stack name and overall status
- Source type (local, GitHub, built-in)
- Compose file path
- Per-service status, health, CPU, memory
- Public endpoints with URLs

#### `surek logs <stack> [service]`

View logs for a stack or specific service.

```bash
surek logs <stack_name> [service] [-f/--follow] [-t/--tail N]
```

| Argument | Description |
|----------|-------------|
| `stack_name` | Name of stack (use "system" for system containers) |
| `service` | Optional: specific service name |

| Option | Description |
|--------|-------------|
| `-f`, `--follow` | Follow log output (stream) |
| `-t`, `--tail` | Output last N lines (default: 100) |

**What it does:**
Runs `docker compose logs` with specified options.

#### `surek validate <path>`

Validate a stack configuration file.

```bash
surek validate <path_to_surek.stack.yml>
```

| Argument | Description |
|----------|-------------|
| `path` | Path to surek.stack.yml file |

**What it does:**
1. Parses and validates the configuration
2. Reports validation errors if any
3. Shows stack name, source, and endpoints if valid

#### `surek reset <stack>`

Reset a stack by stopping it and deleting all data.

```bash
surek reset <stack_name> [--force/-f]
```

| Argument | Description |
|----------|-------------|
| `stack_name` | Name of stack to reset (use "system" for system containers) |

| Option | Description |
|--------|-------------|
| `--force`, `-f` | Skip confirmation prompt |

**What it does:**
1. Stops all containers (with `docker compose stop`)
2. Removes project directory (`surek-data/projects/<stack>/`)
3. Removes volume data (`surek-data/volumes/<stack>/`)
4. **WARNING**: This deletes all data and cannot be undone

#### `surek prune`

Remove unused Docker resources.

```bash
surek prune [--volumes/-v] [--force/-f]
```

| Option | Description |
|--------|-------------|
| `--volumes`, `-v` | Also remove unused Docker volumes and orphan folders |
| `--force`, `-f` | Skip confirmation prompt |

**What it does:**
1. Runs `docker container prune -f` (removes stopped containers)
2. Runs `docker network prune -f` (removes unused networks)
3. Runs `docker image prune -f` (removes dangling images)
4. With `--volumes`:
   - Runs `docker volume prune -f` (removes unused Docker volumes)
   - Removes orphan folders in `surek-data/volumes/` (folders for stacks that no longer exist)

### Backup Commands

#### `surek backup` or `surek backup list`

List all backups in S3.

```bash
surek backup [list] [--json]
```

| Option | Description |
|--------|-------------|
| `--json` | Output as JSON |

**Output columns:**
- Backup name (filename)
- Type: daily, weekly, monthly, manual
- Size
- Created timestamp

#### `surek backup run`

Trigger an immediate manual backup.

```bash
surek backup run
```

**What it does:**
1. Finds the backup container in the system stack
2. Executes backup command inside container with manual backup configuration
3. Creates `manual-backup-YYYY-MM-DDTHH-MM-SS.tar.gz` in S3

#### `surek backup restore`

Restore volumes from a backup.

```bash
surek backup restore [--id BACKUP_NAME] [--stack STACK] [--volume VOLUME]
```

| Option | Description |
|--------|-------------|
| `--id` | Backup filename to restore (interactive selection if omitted) |
| `--stack` | Restore only this stack's volumes |
| `--volume` | Restore only this specific volume |

**What it does:**
1. Lists available backups (if `--id` not provided)
2. Stops affected stacks
3. Downloads backup from S3
4. Decrypts with GPG using backup password
5. Extracts tar.gz archive
6. Copies volumes to `surek-data/volumes/`
7. Restarts stopped stacks

---

## TUI Features

Interactive TUI can be launched by running `surek` with no arguments.

### Stacks Tab

Displays all stacks with their status:

| Column | Description |
|--------|-------------|
| Stack | Stack name ("System" for system stack) |
| Status | `✓ Running (N/M)`, `× Down`, `⚠ Partial (N/M)`, `? Unknown` |
| Health | `✓ healthy`, `⚠ X unhealthy`, `starting...`, `-` |
| Path | Folder name (empty for system) |

### Backups Tab

Displays all backups from S3:

| Column | Description |
|--------|-------------|
| Backup | Filename |
| Type | daily, weekly, monthly, manual |
| Size | Human-readable size |
| Created | Timestamp |

### Keyboard Shortcuts

| Key | Action | Context |
|-----|--------|---------|
| `q` | Quit | Global |
| `r` | Refresh all data | Global |
| `?` | Show help | Global |
| `d` | Deploy selected stack | Stacks tab |
| `s` | Start selected stack | Stacks tab |
| `x` | Stop selected stack | Stacks tab |
| `i`, `Enter`, `→` | Show stack info | Stacks tab |
| Double-click | Show stack info | Stacks tab |

### Stack Info Screen

Shows detailed information:
- Stack name and status
- Source (built-in, local, GitHub)
- Compose file path
- Services table: name, status, health, CPU, memory
- Public endpoints
- Recent logs (if available)

Press `Escape` or `q` to return to main screen.

---

## Writing Docker Compose Files

When writing `docker-compose.yml` for Surek, follow these conventions:

### 1. Use Named Volumes

Surek can only reliably backup **named volumes without additional configuration**. Bind mounts work but won't be backed up.

```yaml
# Good - named volume (backed up)
volumes:
  postgres_data:

services:
  db:
    volumes:
      - postgres_data:/var/lib/postgresql/data

# Bind mount - works but NOT backed up
services:
  app:
    volumes:
      - ./config:/app/config
```

### 2. Unique Service Names

All stacks share the same Docker network. Service names must be unique across ALL stacks.

```yaml
# Bad - generic names will conflict
services:
  postgres:    # Another stack might have "postgres" too!
  redis:

# Good - prefixed with stack name
services:
  myapp-postgres:
  myapp-redis:
```

### 3. No Port Exposure Needed

Caddy routes traffic through the shared network. You don't need to expose ports:

```yaml
# Unnecessary but harmless
services:
  api:
    ports:
      - "3000:3000"

# Better - no ports exposed
services:
  api:
    # Caddy reaches it via surek network on port 3000
```

### 4. Template Variables

Use Surek template variables in your compose file:

```yaml
services:
  app:
    environment:
      - DOMAIN=app.<root>
      - ADMIN_USER=<default_user>
      - ADMIN_PASSWORD=<default_password>
```

### 5. Environment Variables

Standard `${VAR}` syntax is expanded:

```yaml
services:
  app:
    environment:
      - API_KEY=${MY_API_KEY}
      - DEBUG=${DEBUG:-false}
```

### Example Complete Compose File

```yaml
services:
  myapp-web:
    image: myapp:latest
    restart: unless-stopped
    environment:
      - DATABASE_URL=postgres://myapp-db:5432/app
    depends_on:
      - myapp-db

  myapp-db:
    image: postgres:15
    restart: unless-stopped
    environment:
      - POSTGRES_PASSWORD=<default_password>
      - POSTGRES_DB=app
    volumes:
      - myapp_postgres_data:/var/lib/postgresql/data

volumes:
  myapp_postgres_data:
```

---

## Template Variables

Surek template variables use `<variable>` syntax and are expanded in:
- Stack configuration (`surek.stack.yml`)
- Docker Compose files (`docker-compose.yml`)

| Variable | Description | Source |
|----------|-------------|--------|
| `<root>` | Root domain | `surek.yml` → `root_domain` |
| `<default_auth>` | Default credentials (user:password) | `surek.yml` → `default_auth` |
| `<default_user>` | Username from default_auth | Parsed from `default_auth` |
| `<default_password>` | Password from default_auth | Parsed from `default_auth` |
| `<backup_password>` | Backup encryption password | `surek.yml` → `backup.password` |
| `<backup_s3_endpoint>` | S3 endpoint URL | `surek.yml` → `backup.s3_endpoint` |
| `<backup_s3_bucket>` | S3 bucket name | `surek.yml` → `backup.s3_bucket` |
| `<backup_s3_access_key>` | S3 access key | `surek.yml` → `backup.s3_access_key` |
| `<backup_s3_secret_key>` | S3 secret key | `surek.yml` → `backup.s3_secret_key` |

### Environment Variables

Standard shell environment variables are also expanded:

| Syntax | Description |
|--------|-------------|
| `${VAR}` | Replace with environment variable (error if undefined) |
| `${VAR:-default}` | Replace with env var, or "default" if undefined |

**Expansion Order:**
1. Surek template variables (`<root>`, etc.) are expanded first
2. Environment variables (`${VAR}`) are expanded second

---

## Network Architecture

### The Surek Network

Surek creates a Docker bridge network named `surek` that connects all stacks:

```
┌─────────────────────────────────────────────────────────────┐
│                      surek network                          │
│                                                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │
│  │   Caddy     │  │  Portainer  │  │   Netdata   │          │
│  │  (proxy)    │  │   (UI)      │  │ (monitoring)│          │
│  │  :80/:443   │  │   :9000     │  │   :19999    │          │
│  └─────────────┘  └─────────────┘  └─────────────┘          │
│         │                                                   │
│         │ reverse proxy                                     │
│         ▼                                                   │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │
│  │  myapp-web  │  │  myapp-db   │  │ other-stack │          │
│  │   :8080     │  │   :5432     │  │    :3000    │          │
│  └─────────────┘  └─────────────┘  └─────────────┘          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
                            │
                            │ External traffic
                            ▼
                      ┌───────────┐
                      │  Internet │
                      │  :80/:443 │
                      └───────────┘
```

### How Caddy Routes Traffic

1. Caddy listens on ports 80 (HTTP) and 443 (HTTPS)
2. Caddy uses Docker labels to discover services
3. Each public endpoint adds labels to its service:
   ```yaml
   labels:
     caddy: app.example.com
     caddy.reverse_proxy: "{{upstreams 8080}}"
   ```
4. Caddy automatically obtains Let's Encrypt certificates
5. HTTP requests are redirected to HTTPS
6. Traffic is proxied to the service via the shared network

Surek manages all this, no need to configure docker manually.

### Network Creation

The network is created automatically when you run:
```bash
surek start system
# or
surek deploy system
```

It's created as an external bridge network:
```python
client.networks.create(
    name="surek",
    driver="bridge",
    labels={"surek.managed": "true"}
)
```

### Service Connection

During compose transformation, all services are connected to the surek network:

```yaml
# Original
services:
  myapp:
    image: myapp:latest

# Transformed
services:
  myapp:
    image: myapp:latest
    networks:
      - surek

networks:
  surek:
    name: surek
    external: true
```

Services with `network_mode` set are not connected (they use host/none/container networking).

---

## Deployment Pipeline

When `surek deploy <stack>` runs, the following steps occur:

### 1. Source Resolution (GitHub Only)

For `source.type: github`:

```
1. Read github_cache.json to get cached commit hash
2. If --pull NOT set AND project directory exists:
   a. Query GitHub API for latest commit on branch/ref
   b. Compare with cached commit
   c. If same: skip download, use existing files
3. If different OR --pull set:
   a. Download zipball from GitHub
   b. Extract to surek-data/projects/<stack>/
   c. Save commit hash to github_cache.json
```

### 2. File Copy

```
1. For local source:
   - Copy stacks/<stack>/* → surek-data/projects/<stack>/

2. For GitHub source:
   - Downloaded files already in project dir
   - Copy stacks/<stack>/* → surek-data/projects/<stack>/
   - This overlays local files on top of GitHub files
```

### 3. Compose Transformation

The original `docker-compose.yml` is transformed to `docker-compose.surek.yml`:

#### 3a. Variable Expansion

All Surek variables (`<root>`, etc.) and environment variables (`${VAR}`) are expanded throughout the compose spec.

#### 3b. Network Injection

```yaml
# Added to spec
networks:
  surek:
    name: surek
    external: true
```

#### 3c. Volume Transformation

Named volumes are converted to bind mounts for backup support:

```yaml
# Original
volumes:
  postgres_data:

# Transformed
volumes:
  postgres_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /path/to/surek-data/volumes/<stack>/postgres_data
    labels:
      surek.managed: "true"
```

Excluded volumes (from `backup.exclude_volumes`) remain unchanged.

Pre-configured volumes (with existing driver/driver_opts) are skipped with a warning.

#### 3d. Caddy Labels

For each public endpoint, labels are added to the service:

```yaml
# Without auth
labels:
  surek.managed: "true"
  caddy: app.example.com
  caddy.reverse_proxy: "{{upstreams 8080}}"

# With auth (bcrypt hashed, $ escaped to $$)
labels:
  surek.managed: "true"
  caddy: app.example.com
  caddy.reverse_proxy: "{{upstreams 8080}}"
  caddy.basic_auth: ""
  caddy.basic_auth.admin: "$$2b$$14$$..."
```

#### 3e. Environment Injection

Environment variables from stack config are merged into services:

```yaml
# From env.shared - added to ALL services
# From env.by_container.<service> - added to specific service
```

Supports both list and dict environment formats.

#### 3f. Service Network Connection

All services (except those with `network_mode`) get connected to surek network:

```yaml
services:
  myapp:
    networks:
      - surek  # Added
```

### 4. Directory Creation

Volume directories are created if they don't exist:
```
surek-data/volumes/<stack>/<volume_name>/
```

### 5. Start Containers

```bash
docker compose \
  --file surek-data/projects/<stack>/docker-compose.surek.yml \
  --project-directory surek-data/projects/<stack> \
  up -d --build
```

With `--pull` flag:
```bash
docker compose ... up -d --build --pull always
```

---

## Backup System

### Backup Container

The backup container (`offen/docker-volume-backup`) is part of the system stack. It mounts:
- All volumes from `surek-data/volumes/` (read-only)
- Backup configuration files

### Backup Schedules

| Type | Schedule | Retention | Filename Pattern |
|------|----------|-----------|------------------|
| Daily | 2:00 AM daily | 7 days | `daily-backup-YYYY-MM-DDTHH-MM-SS.tar.gz` |
| Weekly | 3:00 AM Monday | 60 days | `weekly-backup-YYYY-MM-DDTHH-MM-SS.tar.gz` |
| Monthly | 4:00 AM 1st of month | 730 days (~2 years) | `monthly-backup-YYYY-MM-DDTHH-MM-SS.tar.gz` |
| Manual | On-demand only | 3650 days (~10 years) | `manual-backup-YYYY-MM-DDTHH-MM-SS.tar.gz` |

### Backup Process

1. Volume data is collected from `surek-data/volumes/`
2. Netdata volumes are excluded (regenerable metrics/cache)
3. User-excluded volumes are skipped
4. Data is compressed with tar/gzip
5. Archive is encrypted with GPG (using backup password)
6. Encrypted file is uploaded to S3

### Restore Process

1. Backup is downloaded from S3
2. GPG decrypts using backup password
3. Tar extracts to temporary directory
4. Volume directories are copied to `surek-data/volumes/`
5. Stacks are restarted

### S3 Compatibility

Supports any S3-compatible storage:
- AWS S3
- Backblaze B2
- MinIO
- DigitalOcean Spaces
- Wasabi
- etc.

---

## Command Internals

### `deploy` Command

```python
def deploy_stack(stack, surek_config, pull=False):
    # 1. Handle GitHub source (download if needed)
    if isinstance(config.source, GitHubSource):
        _handle_github_source(config, project_dir, surek_config, pull)

    # 2. Copy stack files to project directory
    _copy_folder_recursive(source_dir, project_dir)

    # 3. Read and transform compose file
    compose_spec = read_compose_file(compose_file_path)
    transformed = transform_compose_file(compose_spec, config, surek_config)
    write_compose_file(patched_path, transformed)

    # 4. Start containers
    start_stack(config, pull=pull)
```

### `start` Command

```python
def start_stack(config, pull=False):
    # Runs docker compose up
    args = ["-d", "--build"]
    if pull:
        args.extend(["--pull", "always"])
    run_docker_compose(compose_file, project_dir, "up", args)
```

### `stop` Command

```python
def stop_stack(config, silent=False):
    # Runs docker compose stop
    run_docker_compose(compose_file, project_dir, "stop", silent=silent)
```

### `reset` Command

```python
def reset(stack_name, force=False):
    # 1. Stop containers
    stop_stack(config, silent=True)

    # 2. Remove project directory
    shutil.rmtree(project_dir)

    # 3. Remove volumes directory
    shutil.rmtree(volumes_dir)
```

### `prune` Command

```python
def prune(volumes=False, force=False):
    # 1. Find orphan volume folders
    orphan_folders = _find_orphan_volume_folders()

    # 2. Docker cleanup
    run_command(["docker", "container", "prune", "-f"])
    run_command(["docker", "network", "prune", "-f"])
    run_command(["docker", "image", "prune", "-f"])

    if volumes:
        run_command(["docker", "volume", "prune", "-f"])
        # Remove orphan folders
        for name, path in orphan_folders:
            shutil.rmtree(path)
```

### `backup run` Command

```python
def trigger_backup():
    # Find backup container
    containers = client.containers.list(
        filters={"label": [
            "com.docker.compose.project=surek-system",
            "com.docker.compose.service=backup"
        ]}
    )

    # Execute backup command
    container.exec_run([
        "/bin/sh", "-c",
        "set -a; source /etc/dockervolumebackup/conf.d/backup-manual.env; "
        "set +a && backup"
    ])
```

### `backup restore` Command

```python
def restore_backup(backup_id, stack=None, volume=None):
    # 1. Stop affected stacks
    for stack in affected_stacks:
        stop_stack(stack, silent=True)

    # 2. Download backup from S3
    download_backup(config.backup, backup_id, backup_path)

    # 3. Decrypt and extract
    decrypt_and_extract_backup(backup_path, config.backup.password, extract_dir)

    # 4. Restore volumes
    for volume_dir in backup_volumes.iterdir():
        shutil.move(volume_dir, target_volume_dir)

    # 5. Restart stacks
    for stack_name in stopped_stacks:
        start_stack(stack_info.config)
```

---

## Quick Reference

### Common Workflows

**Deploy a new stack:**
```bash
surek new                    # Create stack interactively
# Edit stacks/myapp/surek.stack.yml
# Edit stacks/myapp/docker-compose.yml
surek deploy myapp           # Deploy the stack
```

**Deploy from GitHub:**
```yaml
# stacks/myapp/surek.stack.yml
name: myapp
source:
  type: github
  slug: owner/repo#main
public:
  - domain: app.<root>
    target: web:8080
```

**Update a deployed stack:**
```bash
surek deploy myapp --pull    # Re-pull sources and images
```

**View logs:**
```bash
surek logs myapp             # All services
surek logs myapp web         # Specific service
surek logs myapp -f          # Follow logs
```

**Backup and restore:**
```bash
surek backup list            # List backups
surek backup run             # Manual backup
surek backup restore         # Interactive restore
```

**Cleanup:**
```bash
surek reset myapp            # Remove stack and data
surek prune --volumes        # Clean unused resources
```

### Troubleshooting

**Stack won't start:**
1. Check `surek status` for error messages
2. Run `surek logs <stack>` to see container logs
3. Verify `docker compose` works: `docker compose -f surek-data/projects/<stack>/docker-compose.surek.yml config`

**Caddy not routing:**
1. Verify system stack is running: `surek status`
2. Check Caddy logs: `surek logs system caddy`
3. Verify labels in transformed compose file
4. Verify with user that domain points to server where Surek is running

**Backup failing:**
1. Check backup container logs: `surek logs system backup`
2. Verify S3 credentials in `surek.yml`
3. Test S3 connectivity manually

**GitHub pull failing:**
1. Verify PAT has `repo` scope
2. Check slug format: `owner/repo` or `owner/repo#branch`
3. Test with `curl -H "Authorization: token YOUR_PAT" https://api.github.com/repos/owner/repo`
